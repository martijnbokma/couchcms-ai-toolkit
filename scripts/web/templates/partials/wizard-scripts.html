<script>
    /**
     * Shared wizard navigation functions
     * Used across all wizard steps for consistent behavior
     *
     * CRITICAL: This system ensures ALL selections are preserved throughout the entire wizard,
     * even when navigating multiple steps forward or backward.
     */

    /**
     * Wizard State Management using sessionStorage
     * Single source of truth for all wizard selections
     */
    const WizardState = {
        STORAGE_KEY: 'couchcms-wizard-state',

        /**
         * Save complete wizard state to sessionStorage
         * CRITICAL: Normalize project fields before saving to prevent duplication
         * @param {Object} state - Complete wizard state object
         */
        save(state) {
            try {
                // Normalize project fields to ensure single values (no comma-separated duplicates)
                const normalizedState = { ...state }

                if (normalizedState.projectName) {
                    const normalized = this.normalizeProjectValue(normalizedState.projectName)
                    if (normalized) {
                        normalizedState.projectName = normalized
                    } else {
                        delete normalizedState.projectName
                    }
                }

                if (normalizedState.projectDescription) {
                    const normalized = this.normalizeProjectValue(normalizedState.projectDescription)
                    if (normalized) {
                        normalizedState.projectDescription = normalized
                    } else {
                        delete normalizedState.projectDescription
                    }
                }

                // CRITICAL: Also normalize editors array to remove duplicates
                if (normalizedState.editors && Array.isArray(normalizedState.editors)) {
                    normalizedState.editors = [...new Set(normalizedState.editors)]
                }

                sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(normalizedState))
                console.log('[WizardState.save] Saved normalized state:', normalizedState)
            } catch (error) {
                console.error('[WizardState.save] Error saving state:', error)
            }
        },

        /**
         * Normalize project value to single string (no duplicates)
         * @param {string|string[]} value - Value to normalize
         * @returns {string|null} Normalized single value or null
         */
        normalizeProjectValue(value) {
            if (!value) return null

            // Handle arrays - take LAST value
            if (Array.isArray(value)) {
                const validValues = value.filter(v => v && v !== '' && v !== 'undefined' && v !== 'null')
                if (validValues.length === 0) return null
                return validValues[validValues.length - 1]  // Last value = user input
            }

            // Handle strings - split on comma and take LAST part
            if (typeof value === 'string') {
                const trimmed = value.trim()
                if (!trimmed) return null

                // If contains commas, split and take LAST part
                if (trimmed.includes(',')) {
                    const parts = trimmed.split(',').map(p => p.trim()).filter(p => p)
                    if (parts.length > 0) {
                        return parts[parts.length - 1]  // Last part = user's input
                    }
                    return null
                }

                return trimmed
            }

            return String(value)
        },

        /**
         * Load complete wizard state from sessionStorage
         * @returns {Object} Complete wizard state or empty object
         */
        load() {
            try {
                const stored = sessionStorage.getItem(this.STORAGE_KEY)
                if (stored) {
                    const state = JSON.parse(stored)
                    console.log('[WizardState.load] Loaded state:', state)
                    return state
                }
            } catch (error) {
                console.error('[WizardState.load] Error loading state:', error)
            }
            return {}
        },

        /**
         * Update specific fields in wizard state
         * Merges updates with existing state
         * @param {Object} updates - Fields to update
         */
        update(updates) {
            const current = this.load()
            const updated = { ...current, ...updates }
            this.save(updated)
            return updated
        },

        /**
         * Clear wizard state
         */
        clear() {
            try {
                sessionStorage.removeItem(this.STORAGE_KEY)
                console.log('[WizardState.clear] Cleared state')
            } catch (error) {
                console.error('[WizardState.clear] Error clearing state:', error)
            }
        },

        /**
         * Sync state from hidden fields in current form
         * CRITICAL: This ensures state is always in sync with what the server rendered
         * This is called after HTMX swaps content to sync state from server-rendered hidden fields
         */
        syncFromHiddenFields() {
            const form = document.querySelector('form')
            if (!form) {
                console.log('[WizardState.syncFromHiddenFields] No form found')
                return
            }

            const existingState = this.load()
            const syncedState = { ...existingState }

            // Sync project info
            // CRITICAL: Normalize to string, handle multiple hidden fields with same name
            const normalizeProjectValue = (value) => {
                if (!value) return null
                if (Array.isArray(value)) {
                    const first = value.find(v => v && v !== '' && v !== 'undefined' && v !== 'null')
                    return first || null
                }
                if (typeof value === 'string') {
                    // If comma-separated duplicates, take first part
                    if (value.includes(',') && value.split(',').every(part => part.trim() === value.split(',')[0].trim())) {
                        return value.split(',')[0].trim()
                    }
                    return value
                }
                return String(value)
            }

            // CRITICAL: On project step, prefer visible input over hidden fields
            // Hidden fields are excluded on project step, but if they exist (from navigation),
            // we should still prefer the visible input value
            const projectNameVisibleInput = form.querySelector('input[name="projectName"]:not([type="hidden"])')
            if (projectNameVisibleInput && projectNameVisibleInput.value) {
                // Visible input takes precedence (user's current input)
                const visibleValue = projectNameVisibleInput.value.trim()
                if (visibleValue && visibleValue !== 'my-project' && visibleValue !== projectNameVisibleInput.placeholder) {
                    syncedState.projectName = visibleValue
                }
            }

            // Fallback to hidden fields only if no visible input or visible input has default value
            if (!projectNameVisibleInput || !projectNameVisibleInput.value || projectNameVisibleInput.value.trim() === 'my-project') {
                const projectNameInputs = Array.from(form.querySelectorAll('input[name="projectName"][type="hidden"]'))
                if (projectNameInputs.length > 0) {
                    const projectNameValue = projectNameInputs
                        .map(i => i.value)
                        .find(v => v && v !== '' && v !== 'undefined' && v !== 'null' && v !== 'my-project')
                    if (projectNameValue) {
                        syncedState.projectName = normalizeProjectValue(projectNameValue)
                    }
                }
            }

            const projectDescriptionVisibleInput = form.querySelector('textarea[name="projectDescription"]') || form.querySelector('input[name="projectDescription"]:not([type="hidden"])')
            if (projectDescriptionVisibleInput && projectDescriptionVisibleInput.value) {
                const visibleValue = projectDescriptionVisibleInput.value.trim()
                if (visibleValue && visibleValue !== 'A CouchCMS web application' && visibleValue !== projectDescriptionVisibleInput.placeholder) {
                    syncedState.projectDescription = visibleValue
                }
            }

            if (!projectDescriptionVisibleInput || !projectDescriptionVisibleInput.value || projectDescriptionVisibleInput.value.trim() === 'A CouchCMS web application') {
                const projectDescriptionInputs = Array.from(form.querySelectorAll('input[name="projectDescription"][type="hidden"]'))
                if (projectDescriptionInputs.length > 0) {
                    const projectDescriptionValue = projectDescriptionInputs
                        .map(i => i.value)
                        .find(v => v && v !== '' && v !== 'undefined' && v !== 'null' && v !== 'A CouchCMS web application')
                    if (projectDescriptionValue) {
                        syncedState.projectDescription = normalizeProjectValue(projectDescriptionValue)
                    }
                }
            }

            // Sync setup type
            const setupTypeInputs = Array.from(form.querySelectorAll('input[name="setupType"][type="hidden"]'))
            if (setupTypeInputs.length > 0) {
                const setupTypeValue = setupTypeInputs
                    .map(i => i.value)
                    .find(v => v && v !== '' && v !== 'undefined' && v !== 'null')
                if (setupTypeValue) {
                    syncedState.setupType = normalizeProjectValue(setupTypeValue)
                }
            }

            // Sync CSS selections from hidden fields
            const cssHidden = Array.from(form.querySelectorAll('input[name="css"][type="hidden"]'))
                .map(i => i.value)
                .filter(v => v && v !== 'undefined' && v !== '')
            if (cssHidden.length > 0) {
                syncedState.css = cssHidden
                console.log('[WizardState.syncFromHiddenFields] Synced CSS:', cssHidden)
            }

            // Sync JS selections from hidden fields
            const jsHidden = Array.from(form.querySelectorAll('input[name="js"][type="hidden"]'))
                .map(i => i.value)
                .filter(v => v && v !== 'undefined' && v !== '')
            if (jsHidden.length > 0) {
                syncedState.js = jsHidden
                console.log('[WizardState.syncFromHiddenFields] Synced JS:', jsHidden)
            }

            // Sync editor selections
            // CRITICAL: Check visible checkboxes first (they take precedence), then hidden fields
            const editorsVisible = Array.from(form.querySelectorAll('input[name="editors"][type="checkbox"]:checked'))
                .map(i => i.value)
                .filter(v => v && v !== 'undefined' && v !== '' && v !== 'null')

            if (editorsVisible.length > 0) {
                // Visible checkboxes take precedence
                syncedState.editors = [...new Set(editorsVisible)]  // Remove duplicates
                console.log('[WizardState.syncFromHiddenFields] Synced editors from visible checkboxes:', syncedState.editors)
            } else {
                // Fallback to hidden fields
                const editorsHidden = Array.from(form.querySelectorAll('input[name="editors"][type="hidden"]'))
                    .map(i => i.value)
                    .filter(v => v && v !== 'undefined' && v !== '' && v !== 'null')
                if (editorsHidden.length > 0) {
                    syncedState.editors = [...new Set(editorsHidden)]  // Remove duplicates
                    console.log('[WizardState.syncFromHiddenFields] Synced editors from hidden fields:', syncedState.editors)
                }
            }

            // Sync advanced options
            const frameworkHidden = form.querySelector('input[name="framework"][type="hidden"]')
            if (frameworkHidden && frameworkHidden.value === 'true') {
                syncedState.framework = 'true'
                const doctrine = form.querySelector('input[name="framework_doctrine"][type="hidden"]')
                if (doctrine && doctrine.value === 'true') syncedState.framework_doctrine = 'true'
                const directives = form.querySelector('input[name="framework_directives"][type="hidden"]')
                if (directives && directives.value === 'true') syncedState.framework_directives = 'true'
                const playbooks = form.querySelector('input[name="framework_playbooks"][type="hidden"]')
                if (playbooks && playbooks.value === 'true') syncedState.framework_playbooks = 'true'
                const enhancements = form.querySelector('input[name="framework_enhancements"][type="hidden"]')
                if (enhancements && enhancements.value === 'true') syncedState.framework_enhancements = 'true'
            }

            const contextDirInput = form.querySelector('input[name="contextDir"][type="hidden"]')
            if (contextDirInput && contextDirInput.value) {
                syncedState.contextDir = contextDirInput.value
            }

            // Only update if we found new data
            if (JSON.stringify(syncedState) !== JSON.stringify(existingState)) {
                this.save(syncedState)
                console.log('[WizardState.syncFromHiddenFields] State synced and saved:', syncedState)
            }
        },

        /**
         * Collect all form data from current form
         * CRITICAL: Always preserves existing state - only updates fields that exist in current form
         * This ensures selections are never lost when navigating multiple steps
         * @returns {Object} Complete form data object with all previous selections preserved
         */
        collectFormData() {
            // Always start with existing state to preserve all previous selections
            const existingState = this.load()
            const formData = { ...existingState }

            const form = document.querySelector('form')
            if (form) {
                // Project info (always available if form exists)
                // CRITICAL: Normalize to SINGLE string value, ALWAYS take LAST value to prevent duplication
                // This handles: arrays, comma-separated strings, and ensures no duplicates
                const normalizeProjectValue = (value) => {
                    if (!value) return null

                    // Handle arrays - take LAST value (visible input comes after hidden fields)
                    if (Array.isArray(value)) {
                        const validValues = value.filter(v => v && v !== '' && v !== 'undefined' && v !== 'null')
                        if (validValues.length === 0) return null
                        // Always take LAST value (most recent/user input)
                        return validValues[validValues.length - 1]
                    }

                    // Handle strings - split on comma and take LAST part
                    if (typeof value === 'string') {
                        const trimmed = value.trim()
                        if (!trimmed) return null

                        // If contains commas, split and take LAST part (user's actual input)
                        if (trimmed.includes(',')) {
                            const parts = trimmed.split(',').map(p => p.trim()).filter(p => p)
                            if (parts.length > 0) {
                                // Always take the LAST part - this is the user's input
                                return parts[parts.length - 1]
                            }
                            return null
                        }

                        return trimmed
                    }

                    return String(value)
                }

                // CRITICAL: Always prefer visible input over hidden fields
                // Visible input = user's current input, always takes precedence
                const projectNameInput = form.querySelector('input[name="projectName"]:not([type="hidden"])')
                if (projectNameInput) {
                    const inputValue = projectNameInput.value
                    if (inputValue && inputValue.trim()) {
                        // Normalize the visible input value (handles comma-separated duplicates)
                        const normalized = normalizeProjectValue(inputValue)
                        if (normalized) {
                            formData.projectName = normalized
                            console.log('[collectFormData] Set projectName from visible input:', normalized)
                        }
                    }
                }

                // Only use hidden fields if no visible input or visible input is empty/default
                if (!projectNameInput || !projectNameInput.value || projectNameInput.value.trim() === 'my-project') {
                    const hiddenProjectNameFields = Array.from(form.querySelectorAll('input[name="projectName"][type="hidden"]'))
                    if (hiddenProjectNameFields.length > 0) {
                        // Collect all hidden values and normalize (take last)
                        const allHiddenValues = hiddenProjectNameFields
                            .map(f => f.value)
                            .filter(v => v && v !== '' && v !== 'undefined' && v !== 'null' && v !== 'my-project')
                        if (allHiddenValues.length > 0) {
                            const normalized = normalizeProjectValue(allHiddenValues)
                            if (normalized && !formData.projectName) {
                                formData.projectName = normalized
                                console.log('[collectFormData] Set projectName from hidden fields:', normalized)
                            }
                        }
                    }
                }

                const projectDescriptionInput = form.querySelector('textarea[name="projectDescription"]') || form.querySelector('input[name="projectDescription"]:not([type="hidden"])')
                if (projectDescriptionInput) {
                    const inputValue = projectDescriptionInput.value
                    if (inputValue && inputValue.trim()) {
                        const normalized = normalizeProjectValue(inputValue)
                        if (normalized) {
                            formData.projectDescription = normalized
                            console.log('[collectFormData] Set projectDescription from visible input:', normalized)
                        }
                    }
                }

                if (!projectDescriptionInput || !projectDescriptionInput.value || projectDescriptionInput.value.trim() === 'A CouchCMS web application') {
                    const hiddenProjectDescriptionFields = Array.from(form.querySelectorAll('input[name="projectDescription"][type="hidden"]'))
                    if (hiddenProjectDescriptionFields.length > 0) {
                        const allHiddenValues = hiddenProjectDescriptionFields
                            .map(f => f.value)
                            .filter(v => v && v !== '' && v !== 'undefined' && v !== 'null' && v !== 'A CouchCMS web application')
                        if (allHiddenValues.length > 0) {
                            const normalized = normalizeProjectValue(allHiddenValues)
                            if (normalized && !formData.projectDescription) {
                                formData.projectDescription = normalized
                                console.log('[collectFormData] Set projectDescription from hidden fields:', normalized)
                            }
                        }
                    }
                }

                // Setup type
                const setupTypeInput = form.querySelector('input[name="setupType"]:not([type="hidden"])')
                if (setupTypeInput && setupTypeInput.value) {
                    formData.setupType = setupTypeInput.value
                } else {
                    // Fallback to hidden field if visible input doesn't exist
                    const hiddenSetupType = form.querySelector('input[name="setupType"][type="hidden"]')
                    if (hiddenSetupType && hiddenSetupType.value && !formData.setupType) {
                        formData.setupType = hiddenSetupType.value
                    }
                }

                // Frontend selections (CSS and JS) - only update if fields exist in form
                const cssFields = form.querySelectorAll('input[name="css"]:not([type="hidden"])')
                if (cssFields.length > 0) {
                    const cssCheckboxes = Array.from(form.querySelectorAll('input[name="css"][type="checkbox"]:checked'))
                        .map(i => i.value)
                        .filter(v => v && v !== 'undefined' && v !== '')
                    if (cssCheckboxes.length > 0) {
                        formData.css = cssCheckboxes
                    } else {
                        // If checkboxes exist but none checked, clear selection
                        formData.css = []
                    }
                } else {
                    // CRITICAL: If no visible CSS fields in form, preserve from hidden fields (backward navigation)
                    const hiddenCss = Array.from(form.querySelectorAll('input[name="css"][type="hidden"]'))
                        .map(i => i.value)
                        .filter(v => v && v !== 'undefined' && v !== '' && v !== 'null')
                    if (hiddenCss.length > 0 && (!formData.css || formData.css.length === 0)) {
                        formData.css = hiddenCss
                        console.log('[WizardState.collectFormData] Preserved CSS from hidden fields:', hiddenCss)
                    }
                }
                // If no CSS fields at all, preserve existing state (don't delete)

                const jsFields = form.querySelectorAll('input[name="js"]:not([type="hidden"])')
                if (jsFields.length > 0) {
                    const jsCheckboxes = Array.from(form.querySelectorAll('input[name="js"][type="checkbox"]:checked'))
                        .map(i => i.value)
                        .filter(v => v && v !== 'undefined' && v !== '')
                    if (jsCheckboxes.length > 0) {
                        formData.js = jsCheckboxes
                    } else {
                        formData.js = []
                    }
                } else {
                    // CRITICAL: If no visible JS fields in form, preserve from hidden fields (backward navigation)
                    const hiddenJs = Array.from(form.querySelectorAll('input[name="js"][type="hidden"]'))
                        .map(i => i.value)
                        .filter(v => v && v !== 'undefined' && v !== '' && v !== 'null')
                    if (hiddenJs.length > 0 && (!formData.js || formData.js.length === 0)) {
                        formData.js = hiddenJs
                        console.log('[WizardState.collectFormData] Preserved JS from hidden fields:', hiddenJs)
                    }
                }

                // Editor selections - only update if fields exist in form
                const editorsFields = form.querySelectorAll('input[name="editors"]:not([type="hidden"])')
                if (editorsFields.length > 0) {
                    const editorsCheckboxes = Array.from(form.querySelectorAll('input[name="editors"][type="checkbox"]:checked'))
                        .map(i => i.value)
                        .filter(v => v && v !== 'undefined' && v !== '')
                    if (editorsCheckboxes.length > 0) {
                        // CRITICAL: Remove duplicates using Set
                        formData.editors = [...new Set(editorsCheckboxes)]
                    } else {
                        formData.editors = []
                    }
                } else {
                    // CRITICAL: If no visible editor fields in form, preserve from hidden fields (backward navigation)
                    const hiddenEditors = Array.from(form.querySelectorAll('input[name="editors"][type="hidden"]'))
                        .map(i => i.value)
                        .filter(v => v && v !== 'undefined' && v !== '' && v !== 'null')
                    if (hiddenEditors.length > 0 && (!formData.editors || formData.editors.length === 0)) {
                        // CRITICAL: Remove duplicates using Set
                        formData.editors = [...new Set(hiddenEditors)]
                        console.log('[WizardState.collectFormData] Preserved editors from hidden fields:', formData.editors)
                    }
                }

                // Advanced options - only update if framework checkbox exists in form
                const frameworkCheckbox = form.querySelector('input[name="framework"]:not([type="hidden"])')
                if (frameworkCheckbox) {
                    const framework = frameworkCheckbox.checked || false
                    if (framework) {
                        formData.framework = 'true'
                        formData.framework_doctrine = form.querySelector('input[name="framework_doctrine"]:not([type="hidden"])')?.checked || false ? 'true' : undefined
                        formData.framework_directives = form.querySelector('input[name="framework_directives"]:not([type="hidden"])')?.checked || false ? 'true' : undefined
                        formData.framework_playbooks = form.querySelector('input[name="framework_playbooks"]:not([type="hidden"])')?.checked || false ? 'true' : undefined
                        formData.framework_enhancements = form.querySelector('input[name="framework_enhancements"]:not([type="hidden"])')?.checked || false ? 'true' : undefined
                    } else {
                        // Only clear if framework checkbox exists and is unchecked
                        delete formData.framework
                        delete formData.framework_doctrine
                        delete formData.framework_directives
                        delete formData.framework_playbooks
                        delete formData.framework_enhancements
                    }
                }

                const contextDirInput = form.querySelector('input[name="contextDir"]:not([type="hidden"])')
                if (contextDirInput && contextDirInput.value) {
                    formData.contextDir = contextDirInput.value
                }
            }

            // Ensure setupType is always set
            if (!formData.setupType) {
                formData.setupType = 'simple'
            }

            console.log('[WizardState.collectFormData] Collected form data (preserving existing state):', formData)
            return formData
        },

        /**
         * Convert state object to URLSearchParams
         * CRITICAL: Always merges with existing state to ensure nothing is lost
         * @param {Object} state - State object (optional, will load from storage if not provided)
         * @returns {URLSearchParams} URL parameters with all selections
         */
        toURLParams(state) {
            const params = new URLSearchParams()

            // Always merge with existing state to ensure nothing is lost
            const existingState = this.load()
            const stateToUse = { ...existingState, ...(state || {}) }

            console.log('[WizardState.toURLParams] Merged state:', stateToUse)

            // Always include setup type
            params.append('setupType', stateToUse.setupType || 'simple')

            // Project info
            if (stateToUse.projectName) params.append('projectName', stateToUse.projectName)
            if (stateToUse.projectDescription) params.append('projectDescription', stateToUse.projectDescription)

            // Frontend selections - always include if they exist in state
            if (stateToUse.css && Array.isArray(stateToUse.css) && stateToUse.css.length > 0) {
                stateToUse.css.forEach(c => params.append('css', c))
            }
            if (stateToUse.js && Array.isArray(stateToUse.js) && stateToUse.js.length > 0) {
                stateToUse.js.forEach(j => params.append('js', j))
            }

            // Editor selections - always include if they exist in state
            // CRITICAL: Remove duplicates before adding to URL params
            if (stateToUse.editors && Array.isArray(stateToUse.editors) && stateToUse.editors.length > 0) {
                const uniqueEditors = [...new Set(stateToUse.editors)]
                uniqueEditors.forEach(ed => params.append('editors', ed))
            }

            // Advanced options
            if (stateToUse.framework === 'true') {
                params.append('framework', 'true')
                if (stateToUse.framework_doctrine === 'true') params.append('framework_doctrine', 'true')
                if (stateToUse.framework_directives === 'true') params.append('framework_directives', 'true')
                if (stateToUse.framework_playbooks === 'true') params.append('framework_playbooks', 'true')
                if (stateToUse.framework_enhancements === 'true') params.append('framework_enhancements', 'true')
            }
            if (stateToUse.contextDir) params.append('contextDir', stateToUse.contextDir)

            console.log('[WizardState.toURLParams] Final URL params:', params.toString())
            return params
        }
    }

    /**
     * Navigate to a specific step in the wizard
     * Collects current form data to preserve state and saves to sessionStorage
     * CRITICAL: Always preserves existing state, even when navigating from steps without forms
     */
    function navigateToStep(stepNum, route, setupType) {
        console.log('[navigateToStep] Navigating to step', stepNum, 'route:', route, 'setupType:', setupType)

        // CRITICAL: Always save current form state BEFORE navigating
        const currentFormData = WizardState.collectFormData()
        WizardState.update(currentFormData)

        // Load the updated state (which includes all previous selections)
        const stateToSend = WizardState.load()

        // Override setupType if explicitly provided
        if (setupType) {
            stateToSend.setupType = setupType
            WizardState.save(stateToSend)
        }

        // Convert state to URL parameters
        const params = WizardState.toURLParams(stateToSend)

        // Navigate to the step
        const url = `/api/setup/step/${route}?${params.toString()}`
        console.log('[navigateToStep] HTMX request URL:', url)
        console.log('[navigateToStep] State being sent:', stateToSend)

        htmx.ajax('GET', url, {
            target: '#wizard-content',
            swap: 'innerHTML',
            headers: {
                'HX-Request': 'true'
            }
        }).catch(error => {
            console.error('[navigateToStep] HTMX navigation error:', error)
            alert('Error navigating to step ' + stepNum + '. Please try again.')
        })
    }

    /**
     * Universal back button handler
     * Uses HTMX to navigate back with form data preservation
     * This is the centralized implementation - step-specific goBack() functions should call this
     */
    function goBack(backRoute = null) {
        // CRITICAL: Save current form state before navigating back
        const currentFormData = WizardState.collectFormData()
        WizardState.update(currentFormData)

        // If no route provided, determine it from setupType and current step
        if (!backRoute) {
            const setupType = currentFormData.setupType || 'simple'
            const form = document.querySelector('form')
            const formAction = form?.getAttribute('hx-post') || ''

            // Determine back route based on current step
            // Check if we're on review step by checking the URL or form action
            const currentUrl = window.location.pathname + window.location.search
            const isReviewStep = formAction.includes('/setup/generate') || currentUrl.includes('/step/review') || document.querySelector('form[hx-post*="/setup/generate"]')

            if (isReviewStep) {
                // Review step: go back to previous step based on setup type
                backRoute = setupType === 'simple'
                    ? '/api/setup/step/editors'  // Simple: Review -> Editors
                    : '/api/setup/step/advanced'  // Extended: Review -> Advanced
            } else if (formAction.includes('/step/advanced')) {
                backRoute = setupType === 'simple'
                    ? '/api/setup/step/project'
                    : '/api/setup/step/editors'
            } else if (formAction.includes('/step/editors')) {
                backRoute = setupType === 'simple'
                    ? '/api/setup/step/project'  // Simple: Editors -> Project
                    : '/api/setup/step/frontend'  // Extended: Editors -> Frontend
            } else if (formAction.includes('/step/frontend')) {
                backRoute = '/api/setup/step/project'
            } else if (formAction.includes('/step/complexity')) {
                backRoute = '/api/setup/step/project'
            } else {
                // Default fallback
                backRoute = '/api/setup/step/project'
            }
        }

        // Use HTMX to navigate back with state
        const params = WizardState.toURLParams(currentFormData)
        htmx.ajax('GET', `${backRoute}?${params.toString()}`, {
            target: '#wizard-content',
            swap: 'innerHTML'
        })
    }

    /**
     * Restore form selections from saved state
     * Called after HTMX swaps content to restore checkbox states
     */
    function restoreFormSelections() {
        const state = WizardState.load()
        if (!state || Object.keys(state).length === 0) {
            console.log('[restoreFormSelections] No state to restore')
            return
        }

        const form = document.querySelector('form')
        if (!form) {
            console.log('[restoreFormSelections] No form found')
            return
        }

        console.log('[restoreFormSelections] Restoring state:', state)

        // Restore project info
        // CRITICAL: Normalize to SINGLE string, ALWAYS take LAST value to prevent duplication
        const normalizeToString = (value) => {
            if (!value) return null

            // Handle arrays - take LAST value
            if (Array.isArray(value)) {
                const validValues = value.filter(v => v && v !== '' && v !== 'undefined' && v !== 'null')
                if (validValues.length === 0) return null
                return validValues[validValues.length - 1]  // Last value
            }

            // Handle strings - split on comma and take LAST part
            if (typeof value === 'string') {
                const trimmed = value.trim()
                if (!trimmed) return null

                // If contains commas, split and take LAST part
                if (trimmed.includes(',')) {
                    const parts = trimmed.split(',').map(p => p.trim()).filter(p => p)
                    if (parts.length > 0) {
                        return parts[parts.length - 1]  // Last part = user's input
                    }
                    return null
                }

                return trimmed
            }

            return String(value)
        }

        // CRITICAL: Only restore project fields if they are empty or have default/template values
        // Never overwrite user input - check if field has focus or contains non-default value
        const projectNameInput = form.querySelector('input[name="projectName"]:not([type="hidden"])')
        if (projectNameInput && state.projectName) {
            const currentValue = projectNameInput.value.trim()
            const placeholder = projectNameInput.placeholder || 'my-project'
            const defaultValue = 'my-project'  // Template default
            const normalizedName = normalizeToString(state.projectName)

            // Only restore if:
            // 1. Field is empty, OR
            // 2. Field has default/placeholder value (user hasn't changed it), OR
            // 3. Field doesn't have focus (user is not actively typing)
            const isEmpty = currentValue === ''
            const isDefault = currentValue === defaultValue || currentValue === placeholder
            const hasFocus = document.activeElement === projectNameInput

            if (normalizedName && isEmpty) {
                // Field is empty, safe to restore
                projectNameInput.value = normalizedName
            } else if (normalizedName && isDefault && !hasFocus) {
                // Field has default value and user is not typing, safe to restore
                projectNameInput.value = normalizedName
            } else if (normalizedName && currentValue !== normalizedName && !hasFocus) {
                // Field has different value but user is not typing - restore from state
                // This handles case where user navigated back and template has old value
                projectNameInput.value = normalizedName
            }
            // If field has focus or has non-default value, preserve user input
        }

        const projectDescriptionInput = form.querySelector('textarea[name="projectDescription"]') || form.querySelector('input[name="projectDescription"]:not([type="hidden"])')
        if (projectDescriptionInput && state.projectDescription) {
            const currentValue = projectDescriptionInput.value.trim()
            const placeholder = projectDescriptionInput.placeholder || 'A CouchCMS web application'
            const defaultValue = 'A CouchCMS web application'  // Template default
            const normalizedDescription = normalizeToString(state.projectDescription)

            const isEmpty = currentValue === ''
            const isDefault = currentValue === defaultValue || currentValue === placeholder
            const hasFocus = document.activeElement === projectDescriptionInput

            if (normalizedDescription && isEmpty) {
                projectDescriptionInput.value = normalizedDescription
            } else if (normalizedDescription && isDefault && !hasFocus) {
                projectDescriptionInput.value = normalizedDescription
            } else if (normalizedDescription && currentValue !== normalizedDescription && !hasFocus) {
                projectDescriptionInput.value = normalizedDescription
            }
        }

        // Restore CSS selections
        if (state.css && Array.isArray(state.css)) {
            state.css.forEach(cssId => {
                const checkbox = form.querySelector(`input[name="css"][value="${cssId}"]:not([type="hidden"])`)
                if (checkbox) {
                    checkbox.checked = true
                }
            })
        }

        // Restore JS selections
        if (state.js && Array.isArray(state.js)) {
            state.js.forEach(jsId => {
                const checkbox = form.querySelector(`input[name="js"][value="${jsId}"]:not([type="hidden"])`)
                if (checkbox) {
                    checkbox.checked = true
                }
            })
        }

        // Restore editor selections
        // CRITICAL: Ensure we restore from normalized state (no duplicates)
        if (state.editors && Array.isArray(state.editors) && state.editors.length > 0) {
            // Remove duplicates and normalize
            const uniqueEditors = [...new Set(state.editors.filter(e => e && e !== '' && e !== 'undefined'))]
            console.log('[restoreFormSelections] Restoring editors:', uniqueEditors)

            uniqueEditors.forEach(editorId => {
                const checkbox = form.querySelector(`input[name="editors"][value="${editorId}"]:not([type="hidden"])`)
                if (checkbox) {
                    checkbox.checked = true
                    console.log('[restoreFormSelections] Checked editor:', editorId)
                } else {
                    console.warn('[restoreFormSelections] Editor checkbox not found:', editorId)
                }
            })
        } else {
            console.log('[restoreFormSelections] No editors to restore in state:', state.editors)
        }

        // Restore advanced options
        if (state.framework === 'true') {
            const frameworkCheckbox = form.querySelector('input[name="framework"]:not([type="hidden"])')
            if (frameworkCheckbox) {
                frameworkCheckbox.checked = true
                // Trigger visibility update if function exists
                if (typeof updateFrameworkVisibility === 'function') {
                    updateFrameworkVisibility()
                }
            }
            if (state.framework_doctrine === 'true') {
                const checkbox = form.querySelector('input[name="framework_doctrine"]:not([type="hidden"])')
                if (checkbox) checkbox.checked = true
            }
            if (state.framework_directives === 'true') {
                const checkbox = form.querySelector('input[name="framework_directives"]:not([type="hidden"])')
                if (checkbox) checkbox.checked = true
            }
            if (state.framework_playbooks === 'true') {
                const checkbox = form.querySelector('input[name="framework_playbooks"]:not([type="hidden"])')
                if (checkbox) checkbox.checked = true
            }
            if (state.framework_enhancements === 'true') {
                const checkbox = form.querySelector('input[name="framework_enhancements"]:not([type="hidden"])')
                if (checkbox) checkbox.checked = true
            }
        }

        console.log('[restoreFormSelections] Form selections restored')
    }

    /**
     * HTMX error handling
     */
    document.body.addEventListener('htmx:responseError', function(event) {
        console.error('HTMX Error:', event.detail)
        alert('An error occurred while submitting the form. Please try again.')
    })

    document.body.addEventListener('htmx:sendError', function(event) {
        console.error('HTMX Send Error:', event.detail)
        alert('An error occurred while submitting the form. Please check your internet connection.')
    })

    // Save form state before HTMX form submissions
    document.body.addEventListener('htmx:beforeRequest', function(event) {
        console.log('[htmx:beforeRequest] Event triggered')

        // If this is a form submission, save state first
        if (event.detail.elt && event.detail.elt.tagName === 'FORM') {
            const formData = WizardState.collectFormData()
            WizardState.update(formData)
            console.log('[htmx:beforeRequest] Saved state before form submission:', formData)
        }
    })

    /**
     * Sync state and restore selections after HTMX content swap
     * Uses requestAnimationFrame for reliable DOM timing
     */
    let syncInProgress = false
    function syncAndRestoreState() {
        // Prevent duplicate execution if both afterSettle and afterSwap fire
        if (syncInProgress) {
            console.log('[syncAndRestoreState] Sync already in progress, skipping')
            return
        }
        syncInProgress = true

        try {
            // Step 1: Sync state from server-rendered hidden fields AND visible checkboxes
            // This ensures state is always in sync with what the server rendered
            WizardState.syncFromHiddenFields()

            // Step 2: Restore form selections from synced state
            // Use a small delay to ensure DOM is fully ready
            setTimeout(() => {
                restoreFormSelections()

                // Step 3: Double-check editors after a brief moment (for editors step specifically)
                // Sometimes checkboxes need a moment to be fully rendered
                const form = document.querySelector('form')
                if (form && form.querySelector('input[name="editors"]')) {
                    setTimeout(() => {
                        const state = WizardState.load()
                        if (state.editors && Array.isArray(state.editors) && state.editors.length > 0) {
                            const uniqueEditors = [...new Set(state.editors)]
                            uniqueEditors.forEach(editorId => {
                                const checkbox = form.querySelector(`input[name="editors"][value="${editorId}"]:not([type="hidden"])`)
                                if (checkbox && !checkbox.checked) {
                                    checkbox.checked = true
                                    console.log('[syncAndRestoreState] Double-checked editor:', editorId)
                                }
                            })
                        }
                    }, 50)
                }
            }, 10)
        } finally {
            // Reset flag after a short delay to allow for rapid successive swaps
            setTimeout(() => {
                syncInProgress = false
            }, 200)
        }
    }

    // CRITICAL: Sync state from hidden fields and restore selections after HTMX swap
    // Use htmx:afterSettle if available (fires after all transitions complete)
    // Fallback to htmx:afterSwap with requestAnimationFrame for reliable DOM timing
    document.body.addEventListener('htmx:afterSettle', function(event) {
        console.log('[htmx:afterSettle] Content settled, syncing state')
        syncAndRestoreState()
    })

    // Fallback: Use afterSwap with requestAnimationFrame for browsers/HTMX versions without afterSettle
    // Note: This will also fire if afterSettle exists, but syncInProgress flag prevents duplicate execution
    document.body.addEventListener('htmx:afterSwap', function(event) {
        console.log('[htmx:afterSwap] Content swapped, waiting for DOM stability')
        // Use double requestAnimationFrame to ensure DOM is fully updated and rendered
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                syncAndRestoreState()
            })
        })
    })

    // Make functions available globally
    window.navigateToStep = navigateToStep
    window.goBack = goBack
    window.WizardState = WizardState
    window.restoreFormSelections = restoreFormSelections

    // Fallback: Add event listeners to all step buttons as backup
    document.addEventListener('DOMContentLoaded', function() {
        // Re-bind click handlers after HTMX swaps
        document.body.addEventListener('htmx:afterSwap', function() {
            const stepButtons = document.querySelectorAll('[data-step][data-route]')
            stepButtons.forEach(button => {
                const stepNum = parseInt(button.getAttribute('data-step'))
                const route = button.getAttribute('data-route')
                const setupType = button.closest('[data-setup-type]')?.getAttribute('data-setup-type') ||
                                 document.querySelector('[data-setup-type]')?.getAttribute('data-setup-type') ||
                                 'extended'

                // Remove existing listeners and add new one
                button.removeEventListener('click', handleStepClick)
                button.addEventListener('click', function(e) {
                    e.preventDefault()
                    e.stopPropagation()
                    navigateToStep(stepNum, route, setupType)
                })
            })
        })

        // Initial bind
        const stepButtons = document.querySelectorAll('[data-step][data-route]')
        stepButtons.forEach(button => {
            const stepNum = parseInt(button.getAttribute('data-step'))
            const route = button.getAttribute('data-route')
            const setupType = button.closest('[data-setup-type]')?.getAttribute('data-setup-type') ||
                             document.querySelector('[data-setup-type]')?.getAttribute('data-setup-type') ||
                             'extended'

            button.addEventListener('click', function(e) {
                e.preventDefault()
                e.stopPropagation()
                navigateToStep(stepNum, route, setupType)
            })
        })

        // Initial restore on page load
        setTimeout(() => {
            WizardState.syncFromHiddenFields()
            restoreFormSelections()
        }, 100)

        // CRITICAL: Save user input to state as they type (debounced)
        // This prevents losing input when HTMX swaps occur
        let saveTimeout = null
        const saveUserInput = () => {
            clearTimeout(saveTimeout)
            saveTimeout = setTimeout(() => {
                const formData = WizardState.collectFormData()
                WizardState.update(formData)
                console.log('[saveUserInput] Saved user input to state:', formData)
            }, 300)  // Debounce: save 300ms after user stops typing
        }

        // Listen for input events on project fields
        document.body.addEventListener('input', function(event) {
            const target = event.target
            if (target && (target.name === 'projectName' || target.name === 'projectDescription')) {
                saveUserInput()
            }
        }, true)  // Use capture phase to catch events early
    })

    function handleStepClick(e) {
        e.preventDefault()
        e.stopPropagation()
        const stepNum = parseInt(this.getAttribute('data-step'))
        const route = this.getAttribute('data-route')
        const setupType = this.closest('[data-setup-type]')?.getAttribute('data-setup-type') ||
                         document.querySelector('[data-setup-type]')?.getAttribute('data-setup-type') ||
                         'extended'
        navigateToStep(stepNum, route, setupType)
    }
</script>
