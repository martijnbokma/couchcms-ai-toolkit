---
description: Auto-load refactoring rules for TypeScript files
globs: ['{{paths.typescript}}/**/*.ts']
alwaysApply: false
---

# Refactoring Rules for TypeScript

## üö® CRITICAL: Refactoring Workflow

**When a refactoring request is made (e.g., "refactor @file.ts"), you MUST:**

1. **First**: Load and follow `@ai-toolkit-shared/prompts/refactoring/router.md`
2. **Router will**: Analyze the file, select appropriate specialist(s), request confirmation
3. **Then**: Apply the rules below as part of the selected specialist workflow

**Never skip the router analysis step - it ensures the correct specialist is selected.**

---

When refactoring this file, apply these rules:

## Type Safety

- ‚ùå Never use `any` type (use `unknown` if truly unknown)
- ‚úÖ Define interfaces for all data structures
- ‚úÖ Use `import type` for type-only imports
- ‚úÖ Enable strict mode in tsconfig

## Imports

- ‚ùå Never use barrel file imports: `from './components'`
- ‚ùå Never use index re-exports: `from './index'`
- ‚úÖ Always use direct imports: `from './components/button'`

## Naming Conventions

- Files: `kebab-case.ts` (e.g., `video-player.ts`)
- Variables: `camelCase` (e.g., `videoPlayer`)
- Interfaces/Types: `PascalCase` (e.g., `VideoPlayer`)

## Alpine.js Integration

- Export functions for Alpine.js use on `window`
- Keep Alpine components simple, complex logic in TypeScript
- Define types for Alpine component data

## Error Handling

- Use Result types for expected errors
- Use try/catch for unexpected errors
- Provide meaningful error messages

## Alpine.js Integration

- ‚úÖ Export functions for Alpine.js use on `window`
- ‚úÖ Keep Alpine components simple, complex logic in TypeScript
- ‚úÖ Define types for Alpine component data
- ‚úÖ Use `alpine:init` event for initialization
- ‚úÖ Register functions globally: `window.functionName = functionName`
- ‚úÖ Use Result types for expected errors
- ‚úÖ Provide typed interfaces for component state

## Error Handling

- ‚úÖ Use Result types for expected errors: `Result<T, E>`
- ‚úÖ Use try/catch for unexpected errors
- ‚úÖ Provide meaningful error messages
- ‚úÖ Use type guards for runtime validation
- ‚úÖ Exhaustive switch statements for union types

## Generic Patterns

- ‚úÖ Use generic functions for reusable components
- ‚úÖ Define constraints for generic types: `<T extends { id: string }>`
- ‚úÖ Use `Omit`, `Pick`, `Partial` utility types
- ‚úÖ Create type-safe event emitters with event maps

## Validation

- ‚úÖ Create validation schemas with typed rules
- ‚úÖ Use type guards for runtime type checking
- ‚úÖ Validate external data with Zod or similar
- ‚úÖ Return typed validation results

## API Patterns

- ‚úÖ Define `ApiResponse<T>` interface for API calls
- ‚úÖ Use typed fetch functions
- ‚úÖ Handle errors explicitly (no silent failures)
- ‚úÖ Use async/await with proper error handling

## Checklist

- [ ] No `any` types (use `unknown` if truly unknown)
- [ ] Direct imports only (no barrel files)
- [ ] Proper naming conventions (camelCase, PascalCase, kebab-case)
- [ ] Type-only imports use `import type`
- [ ] Error handling implemented (Result types or try/catch)
- [ ] Alpine integration via window exports
- [ ] Complex Alpine logic extracted to TypeScript
- [ ] Type guards for runtime validation
- [ ] Generic patterns for reusable components
- [ ] Validation schemas for data validation
- [ ] API responses properly typed
- [ ] Exhaustive switch statements for union types


